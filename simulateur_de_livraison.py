# -*- coding: utf-8 -*-
"""Simulateur_de_livraison.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DN_fKQWGUuIDL38YxTZsNhYc2CW1oGnO

Les Ã©tapes de l'implÃ©mentation:
* **Gestion des commandes** : ajouter et rÃ©cupÃ©rer les commandes de la file.
* **ModÃ©lisation du rÃ©seau** : crÃ©er un graphe des trajets possibles avec distances.
* **Algorithme de plus court chemin** : implÃ©menter Dijkstra ou A* pour optimiser les trajets.
* **Gestion des livreurs** : rÃ©partir les commandes et suivre leur Ã©tat.
* **Interface (optionnelle)** : afficher les trajets et les livreurs en action (ex. avec matplotlib).
"""

import queue

class Commande:
    def __init__(self, id_commande, adresse):
        self.id_commande = id_commande
        self.adresse = adresse
        self.statut = "En attente"

    def __str__(self): # sert Ã  afficher un objet sous forme lisible.
        return f"Commande {self.id_commande} - {self.adresse} [{self.statut}]"

import queue # module intÃ©grÃ© qui implÃ©mente plusieurs types de files

class GestionCommandes:
    def __init__(self):
        self.file_commandes = queue.Queue()
        # Queue() est une mÃ©thode qui permet de crÃ©er une file

    def ajouter_commande(self, id_commande, adresse):
        commande = Commande(id_commande, adresse)
        self.file_commandes.put(commande)
        # put() permet d'ajouter une commande dans la file dâ€™attente.
        print(f"âœ… Commande ajoutÃ©e : {commande}")

    def recuperer_commande(self):
        if not self.file_commandes.empty():
            return self.file_commandes.get()
            # get() RÃ©cupÃ¨re la premiÃ¨re commande en attente."""
        else:
            print("âŒ Aucune commande en attente.")
            return None

    def afficher_commandes(self):
        """Affiche toutes les commandes en attente."""
        print("\nğŸ“‹ Commandes en attente :")
        if self.file_commandes.empty():
            print("ğŸ“­ Aucune commande en attente.")
        else:
            for cmd in list(self.file_commandes.queue):
              # self.file_commandes.queue permet d'accÃ©der directement Ã  la liste interne contenant les Ã©lÃ©ments stockÃ©s dans la file.
                print(cmd)

class Livreur:
    def __init__(self, id_livreur):
        self.id_livreur = id_livreur
        self.statut = "Disponible"
        self.commande_actuelle = None

    def __str__(self):
        return f"Livreur {self.id_livreur} - {self.statut}"

    def prendre_commande(self, commande):
        """Attribue une commande au livreur et met Ã  jour son statut."""
        self.commande_actuelle = commande
        commande.statut = "En livraison"
        self.statut = "En livraison"
        print(f"ğŸšš Livreur {self.id_livreur} prend la {commande}")

    def livrer_commande(self):
        """Marque la commande comme livrÃ©e et libÃ¨re le livreur."""
        if self.commande_actuelle:
            self.commande_actuelle.statut = "LivrÃ©e"
            print(f"âœ… {self.commande_actuelle} a Ã©tÃ© livrÃ©e par le livreur {self.id_livreur}")
            self.commande_actuelle = None
            self.statut = "Disponible"

class GestionLivreurs:
    def __init__(self, reseau_routier):
        """Initialise la gestion des livreurs avec accÃ¨s au rÃ©seau routier."""
        self.livreurs = []
        self.reseau_routier = reseau_routier

    def ajouter_livreur(self, id_livreur):
        """Ajoute un livreur Ã  la liste."""
        livreur = Livreur(id_livreur)
        self.livreurs.append(livreur)
        print(f"ğŸ§‘â€âœˆï¸ Livreur ajoutÃ© : {livreur}")

    def attribuer_commande(self, gestion_commandes, lieu_depart="EntrepÃ´t"):
        """Affecte une commande disponible Ã  un livreur libre et anime le trajet."""
        livreur_disponible = next((livreur for livreur in self.livreurs if livreur.statut == "Disponible"), None)
        if livreur_disponible:
            commande = gestion_commandes.recuperer_commande()
            if commande:
                # Trouver l'itinÃ©raire optimal
                chemin, distance = self.reseau_routier.trouver_chemin_optimal(lieu_depart, commande.adresse)
                if chemin:
                    livreur_disponible.prendre_commande(commande)
                    print(f"ğŸ—ºï¸ ItinÃ©raire du livreur {livreur_disponible.id_livreur} : {' â†’ '.join(chemin)} (Distance : {distance} km)")
                    self.reseau_routier.animer_deplacement(chemin)  # Animation du trajet
        else:
            print("ğŸš« Aucun livreur disponible.")

pip install networkx

import networkx as nx
import matplotlib.pyplot as plt
import time

class ReseauRoutier:
    def __init__(self):
        """Initialise un graphe pondÃ©rÃ© pour reprÃ©senter le rÃ©seau routier."""
        self.graphe = nx.Graph()

    def ajouter_lieu(self, nom):
        """Ajoute un point de livraison au graphe."""
        self.graphe.add_node(nom)
        print(f"ğŸ“ Lieu ajoutÃ© : {nom}")

    def ajouter_route(self, lieu1, lieu2, distance):
        """Ajoute une route entre deux lieux avec un poids (distance)."""
        if lieu1 in self.graphe.nodes and lieu2 in self.graphe.nodes:
            self.graphe.add_edge(lieu1, lieu2, weight=distance)
            print(f"ğŸ›£ï¸ Route ajoutÃ©e : {lieu1} â†” {lieu2} ({distance} km)")
        else:
            print(f"âŒ Impossible d'ajouter la route : {lieu1} ou {lieu2} n'existe pas.")

    def trouver_chemin_optimal(self, depart, arrivee):
        """Trouve le chemin le plus court entre deux lieux avec Dijkstra."""
        if depart in self.graphe.nodes and arrivee in self.graphe.nodes:
            chemin = nx.shortest_path(self.graphe, source=depart, target=arrivee, weight="weight")
            distance = nx.shortest_path_length(self.graphe, source=depart, target=arrivee, weight="weight")
            print(f"ğŸš€ Chemin optimal : {' â†’ '.join(chemin)} (Distance : {distance} km)")
            return chemin, distance
        else:
            print(f"âŒ Lieux invalides : {depart} ou {arrivee} n'existe pas.")
            return None, None

    def afficher_reseau(self):
        """Affiche le rÃ©seau routier avec Matplotlib."""
        plt.figure(figsize=(8, 6))
        pos = nx.spring_layout(self.graphe)
        nx.draw(self.graphe, pos, with_labels=True, node_color='skyblue', node_size=2000, font_size=10, font_weight='bold', edge_color='gray')
        labels = nx.get_edge_attributes(self.graphe, 'weight')
        nx.draw_networkx_edge_labels(self.graphe, pos, edge_labels=labels, font_size=10, font_color='red')
        plt.title("ğŸ“Œ RÃ©seau Routier des Livraisons")
        plt.show()

    def animer_deplacement(self, chemin):
        """Anime le dÃ©placement d'un livreur sur le graphe."""
        pos = nx.spring_layout(self.graphe)
        plt.ion()  # Mode interactif pour mise Ã  jour dynamique
        fig, ax = plt.subplots(figsize=(8, 6))

        for i in range(len(chemin)):
            ax.clear()
            nx.draw(self.graphe, pos, with_labels=True, node_color='skyblue', node_size=2000, font_size=10, font_weight='bold', edge_color='gray')
            labels = nx.get_edge_attributes(self.graphe, 'weight')
            nx.draw_networkx_edge_labels(self.graphe, pos, edge_labels=labels, font_size=10, font_color='red')

            # Dessiner le chemin parcouru en rouge
            nx.draw_networkx_edges(self.graphe, pos, edgelist=[(chemin[j], chemin[j+1]) for j in range(i)], edge_color='red', width=2)

            # Dessiner le livreur en mouvement (cercle jaune)
            nx.draw_networkx_nodes(self.graphe, pos, nodelist=[chemin[i]], node_color='yellow', node_size=2500)

            plt.title(f"ğŸ“ Livraison en cours : {' â†’ '.join(chemin[:i+1])}")
            plt.pause(1)  # Pause de 1 seconde pour animation

        plt.ioff()
        plt.show()

# Initialisation
reseau = ReseauRoutier()
gestion_commandes = GestionCommandes()
gestion_livreurs = GestionLivreurs(reseau)

# Ajout des lieux et routes
reseau.ajouter_lieu("EntrepÃ´t")
reseau.ajouter_lieu("Rue de Paris")
reseau.ajouter_lieu("Avenue des Champs")
reseau.ajouter_lieu("Place de la RÃ©publique")
reseau.ajouter_route("EntrepÃ´t", "Rue de Paris", 5)
reseau.ajouter_route("Rue de Paris", "Avenue des Champs", 3)
reseau.ajouter_route("Avenue des Champs", "Place de la RÃ©publique", 4)
reseau.ajouter_route("EntrepÃ´t", "Place de la RÃ©publique", 7)

# Ajout des livreurs et commandes
gestion_livreurs.ajouter_livreur(1)
gestion_livreurs.ajouter_livreur(2)
gestion_commandes.ajouter_commande(1, "Rue de Paris")
gestion_commandes.ajouter_commande(2, "Place de la RÃ©publique")

# Attribution et animation des trajets
gestion_livreurs.attribuer_commande(gestion_commandes)
gestion_livreurs.attribuer_commande(gestion_commandes)







