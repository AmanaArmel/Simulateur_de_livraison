# -*- coding: utf-8 -*-
"""Simulateur_de_livraison.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DN_fKQWGUuIDL38YxTZsNhYc2CW1oGnO

Les étapes de l'implémentation:
* **Gestion des commandes** : ajouter et récupérer les commandes de la file.
* **Modélisation du réseau** : créer un graphe des trajets possibles avec distances.
* **Algorithme de plus court chemin** : implémenter Dijkstra ou A* pour optimiser les trajets.
* **Gestion des livreurs** : répartir les commandes et suivre leur état.
* **Interface (optionnelle)** : afficher les trajets et les livreurs en action (ex. avec matplotlib).
"""

import queue

class Commande:
    def __init__(self, id_commande, adresse):
        self.id_commande = id_commande
        self.adresse = adresse
        self.statut = "En attente"

    def __str__(self): # sert à afficher un objet sous forme lisible.
        return f"Commande {self.id_commande} - {self.adresse} [{self.statut}]"

import queue # module intégré qui implémente plusieurs types de files

class GestionCommandes:
    def __init__(self):
        self.file_commandes = queue.Queue()
        # Queue() est une méthode qui permet de créer une file

    def ajouter_commande(self, id_commande, adresse):
        commande = Commande(id_commande, adresse)
        self.file_commandes.put(commande)
        # put() permet d'ajouter une commande dans la file d’attente.
        print(f"✅ Commande ajoutée : {commande}")

    def recuperer_commande(self):
        if not self.file_commandes.empty():
            return self.file_commandes.get()
            # get() Récupère la première commande en attente."""
        else:
            print("❌ Aucune commande en attente.")
            return None

    def afficher_commandes(self):
        """Affiche toutes les commandes en attente."""
        print("\n📋 Commandes en attente :")
        if self.file_commandes.empty():
            print("📭 Aucune commande en attente.")
        else:
            for cmd in list(self.file_commandes.queue):
              # self.file_commandes.queue permet d'accéder directement à la liste interne contenant les éléments stockés dans la file.
                print(cmd)

class Livreur:
    def __init__(self, id_livreur):
        self.id_livreur = id_livreur
        self.statut = "Disponible"
        self.commande_actuelle = None

    def __str__(self):
        return f"Livreur {self.id_livreur} - {self.statut}"

    def prendre_commande(self, commande):
        """Attribue une commande au livreur et met à jour son statut."""
        self.commande_actuelle = commande
        commande.statut = "En livraison"
        self.statut = "En livraison"
        print(f"🚚 Livreur {self.id_livreur} prend la {commande}")

    def livrer_commande(self):
        """Marque la commande comme livrée et libère le livreur."""
        if self.commande_actuelle:
            self.commande_actuelle.statut = "Livrée"
            print(f"✅ {self.commande_actuelle} a été livrée par le livreur {self.id_livreur}")
            self.commande_actuelle = None
            self.statut = "Disponible"

class GestionLivreurs:
    def __init__(self, reseau_routier):
        """Initialise la gestion des livreurs avec accès au réseau routier."""
        self.livreurs = []
        self.reseau_routier = reseau_routier

    def ajouter_livreur(self, id_livreur):
        """Ajoute un livreur à la liste."""
        livreur = Livreur(id_livreur)
        self.livreurs.append(livreur)
        print(f"🧑‍✈️ Livreur ajouté : {livreur}")

    def attribuer_commande(self, gestion_commandes, lieu_depart="Entrepôt"):
        """Affecte une commande disponible à un livreur libre et anime le trajet."""
        livreur_disponible = next((livreur for livreur in self.livreurs if livreur.statut == "Disponible"), None)
        if livreur_disponible:
            commande = gestion_commandes.recuperer_commande()
            if commande:
                # Trouver l'itinéraire optimal
                chemin, distance = self.reseau_routier.trouver_chemin_optimal(lieu_depart, commande.adresse)
                if chemin:
                    livreur_disponible.prendre_commande(commande)
                    print(f"🗺️ Itinéraire du livreur {livreur_disponible.id_livreur} : {' → '.join(chemin)} (Distance : {distance} km)")
                    self.reseau_routier.animer_deplacement(chemin)  # Animation du trajet
        else:
            print("🚫 Aucun livreur disponible.")

pip install networkx

import networkx as nx
import matplotlib.pyplot as plt
import time

class ReseauRoutier:
    def __init__(self):
        """Initialise un graphe pondéré pour représenter le réseau routier."""
        self.graphe = nx.Graph()

    def ajouter_lieu(self, nom):
        """Ajoute un point de livraison au graphe."""
        self.graphe.add_node(nom)
        print(f"📍 Lieu ajouté : {nom}")

    def ajouter_route(self, lieu1, lieu2, distance):
        """Ajoute une route entre deux lieux avec un poids (distance)."""
        if lieu1 in self.graphe.nodes and lieu2 in self.graphe.nodes:
            self.graphe.add_edge(lieu1, lieu2, weight=distance)
            print(f"🛣️ Route ajoutée : {lieu1} ↔ {lieu2} ({distance} km)")
        else:
            print(f"❌ Impossible d'ajouter la route : {lieu1} ou {lieu2} n'existe pas.")

    def trouver_chemin_optimal(self, depart, arrivee):
        """Trouve le chemin le plus court entre deux lieux avec Dijkstra."""
        if depart in self.graphe.nodes and arrivee in self.graphe.nodes:
            chemin = nx.shortest_path(self.graphe, source=depart, target=arrivee, weight="weight")
            distance = nx.shortest_path_length(self.graphe, source=depart, target=arrivee, weight="weight")
            print(f"🚀 Chemin optimal : {' → '.join(chemin)} (Distance : {distance} km)")
            return chemin, distance
        else:
            print(f"❌ Lieux invalides : {depart} ou {arrivee} n'existe pas.")
            return None, None

    def afficher_reseau(self):
        """Affiche le réseau routier avec Matplotlib."""
        plt.figure(figsize=(8, 6))
        pos = nx.spring_layout(self.graphe)
        nx.draw(self.graphe, pos, with_labels=True, node_color='skyblue', node_size=2000, font_size=10, font_weight='bold', edge_color='gray')
        labels = nx.get_edge_attributes(self.graphe, 'weight')
        nx.draw_networkx_edge_labels(self.graphe, pos, edge_labels=labels, font_size=10, font_color='red')
        plt.title("📌 Réseau Routier des Livraisons")
        plt.show()

    def animer_deplacement(self, chemin):
        """Anime le déplacement d'un livreur sur le graphe."""
        pos = nx.spring_layout(self.graphe)
        plt.ion()  # Mode interactif pour mise à jour dynamique
        fig, ax = plt.subplots(figsize=(8, 6))

        for i in range(len(chemin)):
            ax.clear()
            nx.draw(self.graphe, pos, with_labels=True, node_color='skyblue', node_size=2000, font_size=10, font_weight='bold', edge_color='gray')
            labels = nx.get_edge_attributes(self.graphe, 'weight')
            nx.draw_networkx_edge_labels(self.graphe, pos, edge_labels=labels, font_size=10, font_color='red')

            # Dessiner le chemin parcouru en rouge
            nx.draw_networkx_edges(self.graphe, pos, edgelist=[(chemin[j], chemin[j+1]) for j in range(i)], edge_color='red', width=2)

            # Dessiner le livreur en mouvement (cercle jaune)
            nx.draw_networkx_nodes(self.graphe, pos, nodelist=[chemin[i]], node_color='yellow', node_size=2500)

            plt.title(f"📍 Livraison en cours : {' → '.join(chemin[:i+1])}")
            plt.pause(1)  # Pause de 1 seconde pour animation

        plt.ioff()
        plt.show()

# Initialisation
reseau = ReseauRoutier()
gestion_commandes = GestionCommandes()
gestion_livreurs = GestionLivreurs(reseau)

# Ajout des lieux et routes
reseau.ajouter_lieu("Entrepôt")
reseau.ajouter_lieu("Rue de Paris")
reseau.ajouter_lieu("Avenue des Champs")
reseau.ajouter_lieu("Place de la République")
reseau.ajouter_route("Entrepôt", "Rue de Paris", 5)
reseau.ajouter_route("Rue de Paris", "Avenue des Champs", 3)
reseau.ajouter_route("Avenue des Champs", "Place de la République", 4)
reseau.ajouter_route("Entrepôt", "Place de la République", 7)

# Ajout des livreurs et commandes
gestion_livreurs.ajouter_livreur(1)
gestion_livreurs.ajouter_livreur(2)
gestion_commandes.ajouter_commande(1, "Rue de Paris")
gestion_commandes.ajouter_commande(2, "Place de la République")

# Attribution et animation des trajets
gestion_livreurs.attribuer_commande(gestion_commandes)
gestion_livreurs.attribuer_commande(gestion_commandes)







